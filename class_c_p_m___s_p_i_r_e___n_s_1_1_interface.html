<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Spire: Interface Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Spire
   
   </div>
   <div id="projectbrief">OpenGL wrapper library</div>
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>CPM_SPIRE_NS</b>      </li>
      <li class="navelem"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html">Interface</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Interface Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="CPM_SPIRE_NS::Interface" -->
<p><code>#include &lt;<a class="el" href="_interface_8h_source.html">Interface.h</a>&gt;</code></p>

<p><a href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_p_m___s_p_i_r_e___n_s_1_1_interface_1_1_unsatisfied_uniform.html">UnsatisfiedUniform</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#aa5a9053636a30269210c54e734e0d583">LOG_LEVEL</a> { <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#aa5a9053636a30269210c54e734e0d583ab9f002c6ffbfd511da8090213227454e">LOG_DEBUG</a>, 
<a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#aa5a9053636a30269210c54e734e0d583a80137491015d60640998983941c5b721">LOG_MESSAGE</a>, 
<a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#aa5a9053636a30269210c54e734e0d583a8f6fe15bfe15104da6d1b360194a5400">LOG_WARNING</a>, 
<a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#aa5a9053636a30269210c54e734e0d583a230506cce5c68c3bac5a821c42ed3473">LOG_ERROR</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">All possible log outputs from the renderer. Used via the logging function.  <a href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#aa5a9053636a30269210c54e734e0d583">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a13e98f518885b542b159d7f82c993649">IBO_TYPE</a> { <b>IBO_8BIT</b>, 
<b>IBO_16BIT</b>, 
<b>IBO_32BIT</b>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The different depths supported by the IBO. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a7be4c0897f81657923aac32dc1d1478b">SHADER_TYPES</a> { <br/>
&#160;&#160;<b>VERTEX_SHADER</b>, 
<b>TESSELATION_CONTROL</b>, 
<b>TESSELATION_EVALUATION</b>, 
<b>GEOMETRY_SHADER</b>, 
<br/>
&#160;&#160;<b>FRAGMENT_SHADER</b>, 
<b>COMPUTE_SHADER</b>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a429c36d19ee2c505f6b821c85191e0d5">PRIMITIVE_TYPES</a> { <br/>
&#160;&#160;<b>POINTS</b>, 
<b>LINES</b>, 
<b>LINE_LOOP</b>, 
<b>LINE_STRIP</b>, 
<br/>
&#160;&#160;<b>TRIANGLES</b>, 
<b>TRIANGLE_STRIP</b>, 
<b>TRIANGLE_FAN</b>, 
<b>LINES_ADJACENCY</b>, 
<br/>
&#160;&#160;<b>LINE_STRIP_ADJACENCY</b>, 
<b>TRIANGLES_ADJACENCY</b>, 
<b>TRIANGLE_STRIP_ADJACENCY</b>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a88a6090d3e8c232dfa1103cbf4e1b924">DATA_TYPES</a> { <br/>
&#160;&#160;<a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a88a6090d3e8c232dfa1103cbf4e1b924a66aba953e1da3345bc207065c05c28d8">TYPE_BYTE</a>, 
<a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a88a6090d3e8c232dfa1103cbf4e1b924aff4dabea8530c6a8f46b84e4e21abaa0">TYPE_UBYTE</a>, 
<a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a88a6090d3e8c232dfa1103cbf4e1b924a054c36101e4cd86983d1683871e65dd1">TYPE_SHORT</a>, 
<a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a88a6090d3e8c232dfa1103cbf4e1b924a4d7391ad2373cf2a9fa60dfc83d10431">TYPE_USHORT</a>, 
<br/>
&#160;&#160;<a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a88a6090d3e8c232dfa1103cbf4e1b924a4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>, 
<a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a88a6090d3e8c232dfa1103cbf4e1b924aba807ad7d41a3ac08fd4a71e9e013192">TYPE_UINT</a>, 
<a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a88a6090d3e8c232dfa1103cbf4e1b924a19a0a402d33a2e049e91ea9e37e90c2f">TYPE_FLOAT</a>, 
<a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a88a6090d3e8c232dfa1103cbf4e1b924ae430d491a1ee43e9161ad8f8dd2aae31">TYPE_HALFFLOAT</a>, 
<br/>
&#160;&#160;<a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a88a6090d3e8c232dfa1103cbf4e1b924a019d94f7c571e36215cc1a41e825de0c">TYPE_DOUBLE</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for setting up incoming shader attributes.  <a href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a88a6090d3e8c232dfa1103cbf4e1b924">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fc421023990b77c23bf74eb27c2cca4"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::LogFunction" ref="a1fc421023990b77c23bf74eb27c2cca4" args="" -->
typedef std::function&lt; void(const <br class="typebreak"/>
std::string <br class="typebreak"/>
&amp;, <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#aa5a9053636a30269210c54e734e0d583">Interface::LOG_LEVEL</a> level)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LogFunction</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a44738dc073cad5452e58cb7589b13398">Interface</a> (std::shared_ptr&lt; <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_context.html">Context</a> &gt; context, const std::vector&lt; std::string &gt; &amp;shaderDirs, LogFunction logFP=LogFunction())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a847b013375cba7195fbec71bf1e4f42a">beginFrame</a> (bool makeContextCurrent=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a275cb0fc5850b339346d533d2e65aaa8">endFrame</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a09139a129a54e37a47eeca390ab19ce1">renderObject</a> (const std::string &amp;objectName, const std::string &amp;pass=SPIRE_DEFAULT_PASS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a4c5a5520506b00ad246a8bed835a03a8">addVBO</a> (const std::string &amp;name, const uint8_t *vboData, size_t vboSize, const std::vector&lt; std::string &gt; &amp;attribNames)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a29eb1150a9d2dea41042e8b182dda775">addIBO</a> (const std::string &amp;name, const uint8_t *iboData, size_t iboSize, <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a13e98f518885b542b159d7f82c993649">IBO_TYPE</a> type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#ace916d6201f9615f01892578c606f229">getNumObjects</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; SpireObject &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#ab991b1ed5f7ac16c738e7acd261c4dd5">getObjectWithName</a> (const std::string &amp;name) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a38aa1034e687625ffb0129b98b64647c">clearGLResources</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a65202aa1ddb1d76b51b8c3a1435d88f9">makeCurrent</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74a45d2648335936561898c390281a6a"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::terminate" ref="a74a45d2648335936561898c390281a6a" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>terminate</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d94364dc3e604c86d267ff8cd636d8e"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addObject" ref="a6d94364dc3e604c86d267ff8cd636d8e" args="(const std::string &amp;object)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a6d94364dc3e604c86d267ff8cd636d8e">addObject</a> (const std::string &amp;object)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a renderable 'object' to the scene. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a361548d664c5c29828587c538a2a0890">removeObject</a> (const std::string &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a263619d4f2cf50636e85271fe47767ba"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::removeAllObjects" ref="a263619d4f2cf50636e85271fe47767ba" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a263619d4f2cf50636e85271fe47767ba">removeAllObjects</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all objects from the system. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a66b371069206bea38f5015c17586d37c">addVBO</a> (const std::string &amp;name, std::shared_ptr&lt; std::vector&lt; uint8_t &gt;&gt; vboData, const std::vector&lt; std::string &gt; &amp;attribNames)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a270d4f58bb0d2547d9ab9f8cb120a0d1"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::removeVBO" ref="a270d4f58bb0d2547d9ab9f8cb120a0d1" args="(const std::string &amp;vboName)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeVBO</b> (const std::string &amp;vboName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#acbdbdfc245661ce94330868d0f231070">addIBO</a> (const std::string &amp;name, std::shared_ptr&lt; std::vector&lt; uint8_t &gt;&gt; iboData, <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a13e98f518885b542b159d7f82c993649">IBO_TYPE</a> type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#af8dda0cc7d1af393b5f3550d2b30a57f">removeIBO</a> (const std::string &amp;iboName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a9bdfad3c9bf6b8a03863ac562cd7da9d">addPassToObject</a> (const std::string &amp;object, const std::string &amp;program, const std::string &amp;vboName, const std::string &amp;iboName, <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a429c36d19ee2c505f6b821c85191e0d5">PRIMITIVE_TYPES</a> type, const std::string &amp;pass=SPIRE_DEFAULT_PASS, const std::string &amp;parentPass=&quot;&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#ab0eaa1c8e9afcceb346e7c1a42a8dc66">removePassFromObject</a> (const std::string &amp;object, const std::string &amp;pass)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_c_p_m___s_p_i_r_e___n_s_1_1_interface_1_1_unsatisfied_uniform.html">UnsatisfiedUniform</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a19a88be803cdb43df8daca7ca079ca73">getUnsatisfiedUniforms</a> (const std::string &amp;object, const std::string &amp;pass=SPIRE_DEFAULT_PASS)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a6dbfb32531134674156ef4f519af5a08">addObjectPassUniform</a> (const std::string &amp;object, const std::string &amp;uniformName, T uniformData, const std::string &amp;pass=SPIRE_DEFAULT_PASS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a842a5b5c07f2205c9495eaf474ebd7ad"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addObjectPassUniformConcrete" ref="a842a5b5c07f2205c9495eaf474ebd7ad" args="(const std::string &amp;object, const std::string &amp;uniformName, std::shared_ptr&lt; AbstractUniformStateItem &gt; item, const std::string &amp;pass=SPIRE_DEFAULT_PASS)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a842a5b5c07f2205c9495eaf474ebd7ad">addObjectPassUniformConcrete</a> (const std::string &amp;object, const std::string &amp;uniformName, std::shared_ptr&lt; AbstractUniformStateItem &gt; item, const std::string &amp;pass=SPIRE_DEFAULT_PASS)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete implementation of the above templated function. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a46aa83b8523b40c6afe9c1ecf66db645">addObjectGlobalUniform</a> (const std::string &amp;object, const std::string &amp;uniformName, T uniformData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca877b7d9ec9b2d4fe041cad123489a8"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addObjectGlobalUniformConcrete" ref="aca877b7d9ec9b2d4fe041cad123489a8" args="(const std::string &amp;object, const std::string &amp;uniformName, std::shared_ptr&lt; AbstractUniformStateItem &gt; item)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#aca877b7d9ec9b2d4fe041cad123489a8">addObjectGlobalUniformConcrete</a> (const std::string &amp;object, const std::string &amp;uniformName, std::shared_ptr&lt; AbstractUniformStateItem &gt; item)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete implementation of the above templated function. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a89c87d3a9399c8fda130383f1fc30850">addGlobalUniform</a> (const std::string &amp;uniformName, T uniformData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6a5defe6a09ec00cb90ab73536ac5ef"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addGlobalUniformConcrete" ref="af6a5defe6a09ec00cb90ab73536ac5ef" args="(const std::string &amp;uniformName, std::shared_ptr&lt; AbstractUniformStateItem &gt; item)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#af6a5defe6a09ec00cb90ab73536ac5ef">addGlobalUniformConcrete</a> (const std::string &amp;uniformName, std::shared_ptr&lt; AbstractUniformStateItem &gt; item)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete implementation of the above templated function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a770f2111d69db018c264482afda08696">addObjectPassGPUState</a> (const std::string &amp;object, const GPUState &amp;state, const std::string &amp;pass=SPIRE_DEFAULT_PASS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55669699ffb919f30f83d172f58e7693"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::applyGPUState" ref="a55669699ffb919f30f83d172f58e7693" args="(const GPUState &amp;state, bool force)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a55669699ffb919f30f83d172f58e7693">applyGPUState</a> (const GPUState &amp;state, bool force)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the given GPU state. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a781aeca6aa7c02775bc77302ee6f00ea">getGlobalUniform</a> (const std::string &amp;uniformName)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a9e5852cd42dff7320705b3c7957e015e">getObjectPassUniform</a> (const std::string &amp;objectName, const std::string &amp;uniformName, const std::string &amp;pass=SPIRE_DEFAULT_PASS)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6a11030baa24b5cee659887a50354370"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::getObjectGlobalUniform" ref="a6a11030baa24b5cee659887a50354370" args="(const std::string &amp;objectName, const std::string &amp;uniformName)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getObjectGlobalUniform</b> (const std::string &amp;objectName, const std::string &amp;uniformName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d4fb84b906a674a0fdd799b5576f6db"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addShaderAttribute" ref="a2d4fb84b906a674a0fdd799b5576f6db" args="(const std::string &amp;codeName, size_t numComponents, bool normalize, size_t size, Interface::DATA_TYPES t)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>addShaderAttribute</b> (const std::string &amp;codeName, size_t numComponents, bool normalize, size_t size, <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a88a6090d3e8c232dfa1103cbf4e1b924">Interface::DATA_TYPES</a> t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a86ac8033b5565567ff0eed9462107e0b">addPersistentShader</a> (const std::string &amp;programName, const std::string &amp;vertexShader, const std::string &amp;fragmentShader)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a70490161b0b1a8b3b4308ff686f3007d">addPersistentShader</a> (const std::string &amp;programName, const std::vector&lt; std::tuple&lt; std::string, <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a7be4c0897f81657923aac32dc1d1478b">SHADER_TYPES</a> &gt;&gt; &amp;shaders)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#ac08e248ecd4175f8c46a1da67ed2e8a5">loadProprietarySR5AssetFile</a> (std::istream &amp;stream, std::vector&lt; uint8_t &gt; &amp;vbo, std::vector&lt; uint8_t &gt; &amp;ibo)</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a7c38d5bbeb6f3e2b940877225a4979"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::getGlobalUniformConcrete" ref="a0a7c38d5bbeb6f3e2b940877225a4979" args="(const std::string &amp;uniformName)" -->
std::shared_ptr&lt; const <br class="typebreak"/>
AbstractUniformStateItem &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getGlobalUniformConcrete</b> (const std::string &amp;uniformName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad78b015336974acfbf503cc0d656fb98"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::getObjectPassUniformConcrete" ref="ad78b015336974acfbf503cc0d656fb98" args="(const std::string &amp;object, const std::string &amp;uniformName, const std::string &amp;pass)" -->
std::shared_ptr&lt; const <br class="typebreak"/>
AbstractUniformStateItem &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getObjectPassUniformConcrete</b> (const std::string &amp;object, const std::string &amp;uniformName, const std::string &amp;pass)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a708ad62e7df888670aac9e79c3a5b1c7"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::getObjectGlobalUniformConcrete" ref="a708ad62e7df888670aac9e79c3a5b1c7" args="(const std::string &amp;object, const std::string &amp;uniformName)" -->
std::shared_ptr&lt; const <br class="typebreak"/>
AbstractUniformStateItem &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getObjectGlobalUniformConcrete</b> (const std::string &amp;object, const std::string &amp;uniformName)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6fa852467a46bf962eca1fbfef44592"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::mHub" ref="ad6fa852467a46bf962eca1fbfef44592" args="" -->
std::unique_ptr&lt; Hub &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mHub</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d83a10fc11452be8b015170114b1bc2"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::mImpl" ref="a2d83a10fc11452be8b015170114b1bc2" args="" -->
std::shared_ptr<br class="typebreak"/>
&lt; InterfaceImplementation &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mImpl</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html">Interface</a> to the renderer. A new interface will need to be created per-context. Spire expects that only one thread will be communicating with it at any given time. </p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a88a6090d3e8c232dfa1103cbf4e1b924"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::DATA_TYPES" ref="a88a6090d3e8c232dfa1103cbf4e1b924" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a88a6090d3e8c232dfa1103cbf4e1b924">DATA_TYPES</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used for setting up incoming shader attributes. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a88a6090d3e8c232dfa1103cbf4e1b924a66aba953e1da3345bc207065c05c28d8"></a><!-- doxytag: member="TYPE_BYTE" ref="a88a6090d3e8c232dfa1103cbf4e1b924a66aba953e1da3345bc207065c05c28d8" args="" -->TYPE_BYTE</em>&nbsp;</td><td>
<p>GLbyte - 8-bit signed integer, C-Type (signed char), Suffix (b) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a88a6090d3e8c232dfa1103cbf4e1b924aff4dabea8530c6a8f46b84e4e21abaa0"></a><!-- doxytag: member="TYPE_UBYTE" ref="a88a6090d3e8c232dfa1103cbf4e1b924aff4dabea8530c6a8f46b84e4e21abaa0" args="" -->TYPE_UBYTE</em>&nbsp;</td><td>
<p>GLubyte - 8-bit unsigned integer, C-Type (unsigned char), Suffix (ub) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a88a6090d3e8c232dfa1103cbf4e1b924a054c36101e4cd86983d1683871e65dd1"></a><!-- doxytag: member="TYPE_SHORT" ref="a88a6090d3e8c232dfa1103cbf4e1b924a054c36101e4cd86983d1683871e65dd1" args="" -->TYPE_SHORT</em>&nbsp;</td><td>
<p>GLshort - 16-bit integer, C-Type (short), Suffix (s) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a88a6090d3e8c232dfa1103cbf4e1b924a4d7391ad2373cf2a9fa60dfc83d10431"></a><!-- doxytag: member="TYPE_USHORT" ref="a88a6090d3e8c232dfa1103cbf4e1b924a4d7391ad2373cf2a9fa60dfc83d10431" args="" -->TYPE_USHORT</em>&nbsp;</td><td>
<p>GLushort - 16-bit unsigned integer,C-Type (unsigned short),Suffix (us) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a88a6090d3e8c232dfa1103cbf4e1b924a4fcd4421533bb21c827865bdbac4fef9"></a><!-- doxytag: member="TYPE_INT" ref="a88a6090d3e8c232dfa1103cbf4e1b924a4fcd4421533bb21c827865bdbac4fef9" args="" -->TYPE_INT</em>&nbsp;</td><td>
<p>GLint - 32-bit integer C-Type (long), Suffix (I) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a88a6090d3e8c232dfa1103cbf4e1b924aba807ad7d41a3ac08fd4a71e9e013192"></a><!-- doxytag: member="TYPE_UINT" ref="a88a6090d3e8c232dfa1103cbf4e1b924aba807ad7d41a3ac08fd4a71e9e013192" args="" -->TYPE_UINT</em>&nbsp;</td><td>
<p>GLuint - 32-bit unsigned integer,C-Type (unsigned long), Suffix (ui) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a88a6090d3e8c232dfa1103cbf4e1b924a19a0a402d33a2e049e91ea9e37e90c2f"></a><!-- doxytag: member="TYPE_FLOAT" ref="a88a6090d3e8c232dfa1103cbf4e1b924a19a0a402d33a2e049e91ea9e37e90c2f" args="" -->TYPE_FLOAT</em>&nbsp;</td><td>
<p>GLfloat - 32-bit floating, C-Type (float), Suffix (f) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a88a6090d3e8c232dfa1103cbf4e1b924ae430d491a1ee43e9161ad8f8dd2aae31"></a><!-- doxytag: member="TYPE_HALFFLOAT" ref="a88a6090d3e8c232dfa1103cbf4e1b924ae430d491a1ee43e9161ad8f8dd2aae31" args="" -->TYPE_HALFFLOAT</em>&nbsp;</td><td>
<p>GLfloat - 16-bit floating, C-Type (?), Suffix (?) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a88a6090d3e8c232dfa1103cbf4e1b924a019d94f7c571e36215cc1a41e825de0c"></a><!-- doxytag: member="TYPE_DOUBLE" ref="a88a6090d3e8c232dfa1103cbf4e1b924a019d94f7c571e36215cc1a41e825de0c" args="" -->TYPE_DOUBLE</em>&nbsp;</td><td>
<p>GLdouble - 64-bit floating, C-Type (double), Suffix (d) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5a9053636a30269210c54e734e0d583"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::LOG_LEVEL" ref="aa5a9053636a30269210c54e734e0d583" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#aa5a9053636a30269210c54e734e0d583">LOG_LEVEL</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>All possible log outputs from the renderer. Used via the logging function. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa5a9053636a30269210c54e734e0d583ab9f002c6ffbfd511da8090213227454e"></a><!-- doxytag: member="LOG_DEBUG" ref="aa5a9053636a30269210c54e734e0d583ab9f002c6ffbfd511da8090213227454e" args="" -->LOG_DEBUG</em>&nbsp;</td><td>
<p>Debug / verbose. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa5a9053636a30269210c54e734e0d583a80137491015d60640998983941c5b721"></a><!-- doxytag: member="LOG_MESSAGE" ref="aa5a9053636a30269210c54e734e0d583a80137491015d60640998983941c5b721" args="" -->LOG_MESSAGE</em>&nbsp;</td><td>
<p>General message. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa5a9053636a30269210c54e734e0d583a8f6fe15bfe15104da6d1b360194a5400"></a><!-- doxytag: member="LOG_WARNING" ref="aa5a9053636a30269210c54e734e0d583a8f6fe15bfe15104da6d1b360194a5400" args="" -->LOG_WARNING</em>&nbsp;</td><td>
<p>Warning. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa5a9053636a30269210c54e734e0d583a230506cce5c68c3bac5a821c42ed3473"></a><!-- doxytag: member="LOG_ERROR" ref="aa5a9053636a30269210c54e734e0d583a230506cce5c68c3bac5a821c42ed3473" args="" -->LOG_ERROR</em>&nbsp;</td><td>
<p>Error. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a429c36d19ee2c505f6b821c85191e0d5"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::PRIMITIVE_TYPES" ref="a429c36d19ee2c505f6b821c85191e0d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a429c36d19ee2c505f6b821c85191e0d5">PRIMITIVE_TYPES</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>See: <a href="http://www.opengl.org/wiki/Primitive">http://www.opengl.org/wiki/Primitive</a> </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Add patch tesselation primitives. </dd></dl>

</div>
</div>
<a class="anchor" id="a7be4c0897f81657923aac32dc1d1478b"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::SHADER_TYPES" ref="a7be4c0897f81657923aac32dc1d1478b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a7be4c0897f81657923aac32dc1d1478b">SHADER_TYPES</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generally not needed at this stage. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd><p class="startdd">Add supported OpenGL version to spire. This will allow us to determine what shaders we should us. </p>
<p class="enddd">See glProvokingVertex for possible flat shading implementations instead of using a geometry shader. </p>
</dd></dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a44738dc073cad5452e58cb7589b13398"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::Interface" ref="a44738dc073cad5452e58cb7589b13398" args="(std::shared_ptr&lt; Context &gt; context, const std::vector&lt; std::string &gt; &amp;shaderDirs, LogFunction logFP=LogFunction())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html">Interface</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_context.html">Context</a> &gt;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>shaderDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogFunction&#160;</td>
          <td class="paramname"><em>logFP</em> = <code>LogFunction()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs an interface to the renderer. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderDirs</td><td>A list of directories to search for shader files. </td></tr>
    <tr><td class="paramname">createThread</td><td>If true, then a thread will be created in which the renderer will run. The renderer will do it's best to manage time allocation and only use cycles when there is something to do. </td></tr>
    <tr><td class="paramname">logFP</td><td>The logging function to use when logging rendering messages. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a89c87d3a9399c8fda130383f1fc30850"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addGlobalUniform" ref="a89c87d3a9399c8fda130383f1fc30850" args="(const std::string &amp;uniformName, T uniformData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a89c87d3a9399c8fda130383f1fc30850">addGlobalUniform</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uniformName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>uniformData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Will add *or* update the global uniform if it already exsits. A shader of a given name is only allowed to be one type. If you attempt to bind different values to a uniform, this function will throw a ShaderUniformTypeError. </p>

</div>
</div>
<a class="anchor" id="a29eb1150a9d2dea41042e8b182dda775"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addIBO" ref="a29eb1150a9d2dea41042e8b182dda775" args="(const std::string &amp;name, const uint8_t *iboData, size_t iboSize, IBO_TYPE type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a29eb1150a9d2dea41042e8b182dda775">addIBO</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>iboData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iboSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a13e98f518885b542b159d7f82c993649">IBO_TYPE</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds an IBO. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the IBO. </td></tr>
    <tr><td class="paramname">iboData</td><td>IBO data. This pointer will NOT be stored in spire. No software backing of this pointer is made. The contents of this pointer are placed directly in an OpenGL buffer.  iboSize Size of iboData in bytes. </td></tr>
    <tr><td class="paramname">type</td><td>Specifies what kind of IBO iboData represents. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbdbdfc245661ce94330868d0f231070"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addIBO" ref="acbdbdfc245661ce94330868d0f231070" args="(const std::string &amp;name, std::shared_ptr&lt; std::vector&lt; uint8_t &gt;&gt; iboData, IBO_TYPE type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a29eb1150a9d2dea41042e8b182dda775">addIBO</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; std::vector&lt; uint8_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>iboData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a13e98f518885b542b159d7f82c993649">IBO_TYPE</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds an IBO. Throws an std::out_of_range exception if the object is not found in the system. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the IBO. You might find it odd that you are naming an IBO, and in certain terms you are right. IBOs are named here to avoid returning an identifier to the IBO. This would require a mutex lock (at the very least) *and* code would need to be run on the rendering thread since that is where the OpenGL context is current. </td></tr>
    <tr><td class="paramname">iboData</td><td>IBO data. This pointer will NOT be stored inside of spire. Unless there is a reference to it out side of spire, it will be destroyed. </td></tr>
    <tr><td class="paramname">type</td><td>Specifies what kind of IBO iboData represents. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46aa83b8523b40c6afe9c1ecf66db645"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addObjectGlobalUniform" ref="a46aa83b8523b40c6afe9c1ecf66db645" args="(const std::string &amp;object, const std::string &amp;uniformName, T uniformData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a46aa83b8523b40c6afe9c1ecf66db645">addObjectGlobalUniform</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uniformName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>uniformData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a uniform that will be consumed regardless of the pass. Pass uniforms take precedence over pass global uniforms. </p>

</div>
</div>
<a class="anchor" id="a770f2111d69db018c264482afda08696"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addObjectPassGPUState" ref="a770f2111d69db018c264482afda08696" args="(const std::string &amp;object, const GPUState &amp;state, const std::string &amp;pass=SPIRE_DEFAULT_PASS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a770f2111d69db018c264482afda08696">addObjectPassGPUState</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GPUState &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pass</em> = <code>SPIRE_DEFAULT_PASS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>GPU state that will be applied directly before the object is rendered. Note: The default GPU state is consists of the default GPUState constructor. </p>

</div>
</div>
<a class="anchor" id="a6dbfb32531134674156ef4f519af5a08"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addObjectPassUniform" ref="a6dbfb32531134674156ef4f519af5a08" args="(const std::string &amp;object, const std::string &amp;uniformName, T uniformData, const std::string &amp;pass=SPIRE_DEFAULT_PASS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a6dbfb32531134674156ef4f519af5a08">addObjectPassUniform</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uniformName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>uniformData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pass</em> = <code>SPIRE_DEFAULT_PASS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Associates a uniform value to the specified object's pass. If the uniform already exists, then its value will be updated if it passes a type check. Throws an std::out_of_range exception if the object or pass is not found in the system. Throws ShaderUniformTypeError if the types do not match what is stored in the shader. </p>

</div>
</div>
<a class="anchor" id="a9bdfad3c9bf6b8a03863ac562cd7da9d"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addPassToObject" ref="a9bdfad3c9bf6b8a03863ac562cd7da9d" args="(const std::string &amp;object, const std::string &amp;program, const std::string &amp;vboName, const std::string &amp;iboName, PRIMITIVE_TYPES type, const std::string &amp;pass=SPIRE_DEFAULT_PASS, const std::string &amp;parentPass=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a9bdfad3c9bf6b8a03863ac562cd7da9d">addPassToObject</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vboName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>iboName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a429c36d19ee2c505f6b821c85191e0d5">PRIMITIVE_TYPES</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pass</em> = <code>SPIRE_DEFAULT_PASS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parentPass</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a geometry pass to an object given by the identifier 'object'. Throws an std::out_of_range exception if the object is not found in the system. If there already exists a geometry pass, it throws a 'Duplicate' exception. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>Unique object name. </td></tr>
    <tr><td class="paramname">program</td><td>Complete shader program to use when rendering. See the oveloaded addPersistentShader functions. </td></tr>
    <tr><td class="paramname">vboName</td><td>VBO to use. </td></tr>
    <tr><td class="paramname">iboName</td><td>IBO to use. </td></tr>
    <tr><td class="paramname">type</td><td>Primitive type. </td></tr>
    <tr><td class="paramname">pass</td><td>Pass name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pass ID. Use this ID to assign uniforms to the pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a86ac8033b5565567ff0eed9462107e0b"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addPersistentShader" ref="a86ac8033b5565567ff0eed9462107e0b" args="(const std::string &amp;programName, const std::string &amp;vertexShader, const std::string &amp;fragmentShader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a86ac8033b5565567ff0eed9462107e0b">addPersistentShader</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>programName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vertexShader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fragmentShader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>NOTE: It is possible to have shader programs implemented inside of the pipe itself. That way, it's easier to detect OpenGL version problems and other things. Adds a persistent shader under the name 'programName'. Default vertex and fragment shader.</p>
<p>Throws an invalid_argument exception if there already exists a program by the same name, and the program specified by this function's arguments does not match the program that already exists. Throws a Duplicate exception if this shader is already in the persistent shader list. </p>

</div>
</div>
<a class="anchor" id="a70490161b0b1a8b3b4308ff686f3007d"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addPersistentShader" ref="a70490161b0b1a8b3b4308ff686f3007d" args="(const std::string &amp;programName, const std::vector&lt; std::tuple&lt; std::string, SHADER_TYPES &gt;&gt; &amp;shaders)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a86ac8033b5565567ff0eed9462107e0b">addPersistentShader</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>programName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; std::string, <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a7be4c0897f81657923aac32dc1d1478b">SHADER_TYPES</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>shaders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>You can build any shader program you want using this method. Before you use this function, ensure that the necessary features are supported by the user's graphics card.</p>
<p>Throws an invalid_argument exception if there already exists a program by the same name, and the program specified by this function's arguments does not match the program that already exists. Throws a Duplicate exception if this shader is already in the persistent shader list.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">shaders</td><td>First tuple argument is the shader program file, the second is the type of shader. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c5a5520506b00ad246a8bed835a03a8"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addVBO" ref="a4c5a5520506b00ad246a8bed835a03a8" args="(const std::string &amp;name, const uint8_t *vboData, size_t vboSize, const std::vector&lt; std::string &gt; &amp;attribNames)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a4c5a5520506b00ad246a8bed835a03a8">addVBO</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>vboData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vboSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>attribNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a VBO. This VBO can be re-used by any objects in the system. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the VBO. See addIBOToObject for a full description of why you are required to name your;t VBO. </td></tr>
    <tr><td class="paramname">vboData</td><td>VBO data. This pointer will NOT be stored in spire.  vboSize VBO data size. </td></tr>
    <tr><td class="paramname">attribNames</td><td>List of attribute names. This is used as a sanity check to ensure that the shader program's expected attributes match up with what you have provided in in the VBO. This only checked when a call to addPassToObject is made. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66b371069206bea38f5015c17586d37c"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::addVBO" ref="a66b371069206bea38f5015c17586d37c" args="(const std::string &amp;name, std::shared_ptr&lt; std::vector&lt; uint8_t &gt;&gt; vboData, const std::vector&lt; std::string &gt; &amp;attribNames)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a4c5a5520506b00ad246a8bed835a03a8">addVBO</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; std::vector&lt; uint8_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>vboData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>attribNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as addVBO in the concurrent interface, but using vectors and shared_ptrs to ensure the data survives its trip into the rendering thread. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the VBO. See addIBOToObject for a full description of why you are required to name your VBO. </td></tr>
    <tr><td class="paramname">vboData</td><td>VBO data. This pointer will NOT be stored inside of spire. Unless there is a reference to it out side of spire, it will be destroyed. </td></tr>
    <tr><td class="paramname">attribNames</td><td>List of attribute names. This is used as a sanity check to ensure that the shader program's expected attributes match up with what you have provided in in the VBO. This only checked when a call to addPassToObject is made. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a847b013375cba7195fbec71bf1e4f42a"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::beginFrame" ref="a847b013375cba7195fbec71bf1e4f42a" args="(bool makeContextCurrent=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a847b013375cba7195fbec71bf1e4f42a">beginFrame</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>makeContextCurrent</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calling this function is not necessary but may make your life. Here is a brief overview of what this function does: Makes the context current if makeContextCurrent == true. Checks the frame buffer status is complete (returns false if not). Clears the depth buffer and color buffer (color buffer is cleared to [0,0,0,1]). Sets a default GPU state by applying a fresh instance of the GPUState class. You don't need to use this function. Just ensure that that the context which you passed into spire is current when you call into Spire. </p>

</div>
</div>
<a class="anchor" id="a38aa1034e687625ffb0129b98b64647c"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::clearGLResources" ref="a38aa1034e687625ffb0129b98b64647c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a38aa1034e687625ffb0129b98b64647c">clearGLResources</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cleans up all GL resources. Should ONLY be called from the rendering thread. In our case, this amounts to disposing of all of our objects and VBO/IBOs and persistent shader objects. </p>

</div>
</div>
<a class="anchor" id="a275cb0fc5850b339346d533d2e65aaa8"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::endFrame" ref="a275cb0fc5850b339346d533d2e65aaa8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a275cb0fc5850b339346d533d2e65aaa8">endFrame</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just calls mContext-&gt;swapBuffers(). Nothing else. Call this as the complement to beginFrame when you are finished. Or don't call it and replace its functionality with something more appropriate for your needs. </p>

</div>
</div>
<a class="anchor" id="a781aeca6aa7c02775bc77302ee6f00ea"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::getGlobalUniform" ref="a781aeca6aa7c02775bc77302ee6f00ea" args="(const std::string &amp;uniformName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a781aeca6aa7c02775bc77302ee6f00ea">getGlobalUniform</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uniformName</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>This really wants to be an 'optional' return value instead of a throw... it would be much more useful and type compliant that way. See: boost::optional. Waiting to see if the standard adopts optional. optional will be added to the standard, but probably not in C++14. Looking for alternate implementation of optional. </dd></dl>

</div>
</div>
<a class="anchor" id="ace916d6201f9615f01892578c606f229"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::getNumObjects" ref="ace916d6201f9615f01892578c606f229" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#ace916d6201f9615f01892578c606f229">getNumObjects</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Obtain the current number of objects. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>This function nedes to go to the implementation. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e5852cd42dff7320705b3c7957e015e"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::getObjectPassUniform" ref="a9e5852cd42dff7320705b3c7957e015e" args="(const std::string &amp;objectName, const std::string &amp;uniformName, const std::string &amp;pass=SPIRE_DEFAULT_PASS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a9e5852cd42dff7320705b3c7957e015e">getObjectPassUniform</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>objectName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uniformName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pass</em> = <code>SPIRE_DEFAULT_PASS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Want optional. </dd></dl>

</div>
</div>
<a class="anchor" id="ab991b1ed5f7ac16c738e7acd261c4dd5"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::getObjectWithName" ref="ab991b1ed5f7ac16c738e7acd261c4dd5" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; SpireObject &gt; <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#ab991b1ed5f7ac16c738e7acd261c4dd5">getObjectWithName</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Obtain the object associated with 'name'. throws std::range_error if the object is not found. </p>

</div>
</div>
<a class="anchor" id="a19a88be803cdb43df8daca7ca079ca73"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::getUnsatisfiedUniforms" ref="a19a88be803cdb43df8daca7ca079ca73" args="(const std::string &amp;object, const std::string &amp;pass=SPIRE_DEFAULT_PASS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_c_p_m___s_p_i_r_e___n_s_1_1_interface_1_1_unsatisfied_uniform.html">Interface::UnsatisfiedUniform</a> &gt; <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a19a88be803cdb43df8daca7ca079ca73">getUnsatisfiedUniforms</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pass</em> = <code>SPIRE_DEFAULT_PASS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the currently unsatisfied uniforms for the object. Commonly used to define what uniforms need to be built for the object on a per-frame basis. </p>

</div>
</div>
<a class="anchor" id="ac08e248ecd4175f8c46a1da67ed2e8a5"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::loadProprietarySR5AssetFile" ref="ac08e248ecd4175f8c46a1da67ed2e8a5" args="(std::istream &amp;stream, std::vector&lt; uint8_t &gt; &amp;vbo, std::vector&lt; uint8_t &gt; &amp;ibo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#ac08e248ecd4175f8c46a1da67ed2e8a5">loadProprietarySR5AssetFile</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ibo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Loads an asset file and populates the given vectors with vbo and ibo data. In the future, we should expand this to include other asset types. Always uses 16bit IBOs and 32bit per component position / normal in the vbo. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of triangles read into ibo. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>This should be moved into SCI-Run appspecific. It doesn't belong in spire. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Use more appropriate I/O exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a65202aa1ddb1d76b51b8c3a1435d88f9"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::makeCurrent" ref="a65202aa1ddb1d76b51b8c3a1435d88f9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a65202aa1ddb1d76b51b8c3a1435d88f9">makeCurrent</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes the rendering context that was passed into spire current on the thread. </p>

</div>
</div>
<a class="anchor" id="af8dda0cc7d1af393b5f3550d2b30a57f"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::removeIBO" ref="af8dda0cc7d1af393b5f3550d2b30a57f" args="(const std::string &amp;iboName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#af8dda0cc7d1af393b5f3550d2b30a57f">removeIBO</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>iboName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes specified ibo from the object. It is safe to issue this call even though some of your passes may still be referencing the VBOs/IBOs. When the passes are destroyed, their associated VBOs/IBOs will be destroyed. </p>

</div>
</div>
<a class="anchor" id="a361548d664c5c29828587c538a2a0890"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::removeObject" ref="a361548d664c5c29828587c538a2a0890" args="(const std::string &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a361548d664c5c29828587c538a2a0890">removeObject</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Completely removes 'object' from the pipe. This includes removing all of the object's passes as well. Throws an std::out_of_range exception if the object is not found in the system. </p>

</div>
</div>
<a class="anchor" id="ab0eaa1c8e9afcceb346e7c1a42a8dc66"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::removePassFromObject" ref="ab0eaa1c8e9afcceb346e7c1a42a8dc66" args="(const std::string &amp;object, const std::string &amp;pass)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#ab0eaa1c8e9afcceb346e7c1a42a8dc66">removePassFromObject</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes a pass from the object. Throws an std::out_of_range exception if the object or pass is not found in the system. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>Unique object name. </td></tr>
    <tr><td class="paramname">pass</td><td>Pass name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09139a129a54e37a47eeca390ab19ce1"></a><!-- doxytag: member="CPM_SPIRE_NS::Interface::renderObject" ref="a09139a129a54e37a47eeca390ab19ce1" args="(const std::string &amp;objectName, const std::string &amp;pass=SPIRE_DEFAULT_PASS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_c_p_m___s_p_i_r_e___n_s_1_1_interface.html#a09139a129a54e37a47eeca390ab19ce1">renderObject</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>objectName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pass</em> = <code>SPIRE_DEFAULT_PASS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Renders an object given a specific pass. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd><p class="startdd">Should we allow extra uniforms to be passed in, or should we stick with the callback function for finding uniforms? Possibly add the callback to this render call so it is clear what is happening with regards to the world transformation. We had to set state with lambdas when we were using the threaded interface, but we don't need to do that here. This would be the 'unsatisfied uniforms callback'. </p>
<p class="enddd">Implement </p>
</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>spire/<a class="el" href="_interface_8h_source.html">Interface.h</a></li>
<li>spire/Interface.cpp</li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 12 2013 01:42:26 for Spire by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
